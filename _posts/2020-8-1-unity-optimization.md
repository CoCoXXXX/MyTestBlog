---

category: Unity
path: '/unity/optimization'
title: 'Unity性能优化'

layout: nil
---

* DallCall是什么？简单来讲其实就是对底层图形程序（比如openDL ES）接口的调用，以在屏幕上画出东西。所以，
是谁去调用这些接口呢？CPU
* Fragment是什么？经常有人说 vf这样的属于，其中的v代表了vertex，即我们都知道是顶点。那f代表的fragment是什么呢？
说他之前需要说一下像素，像素大家应该十分熟悉了。通俗的说，像素是构成数码影像的基本单元。那fragment呢？是有可能成为像素的东西。为什么叫有可能呢？就是最终会不会被画出来不一定，是潜在的像素。所以这会涉及到谁呢？GPU。
* Batching是什么？同样，我相信各位都知道批处理的作用是什么。没错将批处理之前需要很多次调用（DrawCall）的物体合并，之后只需要调用一次底层图形程序的接口就行。听上去就是优化的终极方案啊！但是，理想是美好的，世界是残酷的，一些不足之处之后我们再聊。
* 内存的分配。记住，除了Unity3D自己的内存损耗。我们科室还带着Mono呢，还有托管的那一套东西。更别说有引入自己的几个dll文件了。这些都是内存开销需要考虑的。

**优化时需要注意三个方面：**  
（1）CPU方面.  
（2）GPU方面.  
（3）内存方面.  


### CPU方面的优化
DarwCall影像的是CPU的效率，而且也是在从业者中知名度最高的优化点。但是除了DrawCall之外，还有哪些因素也会影像到CPU效率呢？让我们一一列出比较常见的项目。  
(1)DrawCalls  
(2)物理组建(Physics)  
(3)GC(用来处理内存的，但是是谁使用GC去处理内存呢？)  
(4)脚本中的代码质量

#### 对DrawCall 的优化
DrawCall是CPU调用底层图形接口。比如有上千个物体，每一个渲染都需要调用一次底层接口，而每一次调用CPU都需要做很多工作，那么CPU必然不堪重负。但是对于GPU来说，图形处理的工作量是一样的。所以对DrawCall的优化，主要是就是为了尽量解放CPU在调用图形接口上的开销。所以针对DrawCall主要的思路就是每个物体尽量减少渲染次数。多个物体最好一起渲染。所以，按照这个思路就有了三个方案。  
(1)使用DrawCall Batching,也就是描绘调用批处理。Unity3D在运行时会将一些物体进行合并，从而用一个描绘调用来渲染他们  
(2)通过把这些纹理打包成图集尽量减少材质的使用  
(3)尽量减少使用反光，阴影之类的效果，因为那样会使物体多次渲染。  

#### 使用DrawCall Batching批处理
首先要理解为什么两个没有相同材质的物体，及时使用批处理，也无法实现DrawCall的数量的下降和性能的提升。  
因为被“批处理”的两个物体的网格模型需要使用相同材质的目的，在于其纹理是相同的，这样才可以实现同时渲染的目的。因此保证材质相同，是为了保证被渲染的纹理相同。
因此，为了将两个纹理不通的材质合二为一，就需要将纹理打包成图集，具体到合二为一这种情况，就是将两个纹理合成一个纹理，这样就可以只用一个材质来代替之前的两个材质了。  
而DrawCall Batching 本身，也还会细分为两种，即static Batching 静态批处理和Dynamic Batching 动态批处理。

#### Static Batching 静态批处理  
静态那即是不动的？听上去状态也不会改变，没有“伤害恒明”，比如山，石，楼房，校舍等。那和什么比较类似呢？各位一定觉得和场景的属性很像吧，所以场景似乎就可以采用这种方式来减少DrawCall。  

    
