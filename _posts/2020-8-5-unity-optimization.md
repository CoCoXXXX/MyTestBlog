---

category: Unity
path: '/unity/optimization'
title: 'Unity性能优化'

layout: nil
---

* DallCall是什么？简单来讲其实就是对底层图形程序（比如openDL ES）接口的调用，以在屏幕上画出东西。所以，
是谁去调用这些接口呢？CPU
* Fragment是什么？经常有人说 vf这样的属于，其中的v代表了vertex，即我们都知道是顶点。那f代表的fragment是什么呢？
说他之前需要说一下像素，像素大家应该十分熟悉了。通俗的说，像素是构成数码影像的基本单元。那fragment呢？是有可能成为像素的东西。为什么叫有可能呢？就是最终会不会被画出来不一定，是潜在的像素。所以这会涉及到谁呢？GPU。
* Batching是什么？同样，我相信各位都知道批处理的作用是什么。没错将批处理之前需要很多次调用（DrawCall）的物体合并，之后只需要调用一次底层图形程序的接口就行。听上去就是优化的终极方案啊！但是，理想是美好的，世界是残酷的，一些不足之处之后我们再聊。
* 内存的分配。记住，除了Unity3D自己的内存损耗。我们科室还带着Mono呢，还有托管的那一套东西。更别说有引入自己的几个dll文件了。这些都是内存开销需要考虑的。

**优化时需要注意三个方面：**  
（1）CPU方面.  
（2）GPU方面.  
（3）内存方面.  


## CPU方面的优化
DarwCall影像的是CPU的效率，而且也是在从业者中知名度最高的优化点。但是除了DrawCall之外，还有哪些因素也会影像到CPU效率呢？让我们一一列出比较常见的项目。  
(1)DrawCalls  
(2)物理组建(Physics)  
(3)GC(用来处理内存的，但是是谁使用GC去处理内存呢？)  
(4)脚本中的代码质量

### 对DrawCall 的优化
DrawCall是CPU调用底层图形接口。比如有上千个物体，每一个渲染都需要调用一次底层接口，而每一次调用CPU都需要做很多工作，那么CPU必然不堪重负。但是对于GPU来说，图形处理的工作量是一样的。所以对DrawCall的优化，主要是就是为了尽量解放CPU在调用图形接口上的开销。所以针对DrawCall主要的思路就是每个物体尽量减少渲染次数。多个物体最好一起渲染。所以，按照这个思路就有了三个方案。  
(1)使用DrawCall Batching,也就是描绘调用批处理。Unity3D在运行时会将一些物体进行合并，从而用一个描绘调用来渲染他们  
(2)通过把这些纹理打包成图集尽量减少材质的使用  
(3)尽量减少使用反光，阴影之类的效果，因为那样会使物体多次渲染。  

#### 使用DrawCall Batching批处理
首先要理解为什么两个没有相同材质的物体，及时使用批处理，也无法实现DrawCall的数量的下降和性能的提升。  
因为被“批处理”的两个物体的网格模型需要使用相同材质的目的，在于其纹理是相同的，这样才可以实现同时渲染的目的。因此保证材质相同，是为了保证被渲染的纹理相同。
因此，为了将两个纹理不通的材质合二为一，就需要将纹理打包成图集，具体到合二为一这种情况，就是将两个纹理合成一个纹理，这样就可以只用一个材质来代替之前的两个材质了。  
而DrawCall Batching 本身，也还会细分为两种，即static Batching 静态批处理和Dynamic Batching 动态批处理。

#### Static Batching 静态批处理  
静态那即是不动的？听上去状态也不会改变，没有“伤害恒明”，比如山，石，楼房，校舍等。那和什么比较类似呢？各位一定觉得和场景的属性很像吧，所以场景似乎就可以采用这种方式来减少DrawCall。  
 那么对静态批处理下个定义：只要这些物体不移动，并且拥有相同的材质，静态批处理就允许引擎对任意大小的几何物体进行批处理操作来降低描绘调用。  
那要如何使用静态批处理来较少DrawCall呢？只需要明确指出哪些物体是静止的，并且在游戏中永远不会移动，旋转和缩放。想完成这一步，只需要在检测面板（inspector）中勾选“static”复选框。
 
#### Dynamic Batching 动态批处理
 首先要明确一点，Unity3D的DrawCall动态批处理机制是引擎自动进行的，无需像静态批处理那样手动设置Static。与一个实例化Prefab的例子。如果动态物体共享相同的材质，则引擎会自动对DrawCall优化，也就是使用批处理。首先将一个Cube做成Prefab，然后再实例化500次，看看DrawCall数量，代码如下：


   ```for(int i = 0; i< 500; i++)
  {
      GameObject cube;
      cube = GameObject.Instantiate(prefab) as GameObject;
  }
  //DrawCall 为1 ```

 可以看到DrawCall的数量为1，Batching的数量是499.而在这个过程中，除了实例化创建物体职位什么都没做，不错Unity3D引擎自动处理了这种情况。  
  但是有很多开发者也遇到这种情况，就是也是从prefab实例化创建的物体，为什么DrawCall依然很高呢？这就是上文说的DrawCall的动态批处理存在着很多约束。下面来演示一下。针对cube这样简单的物体的创建，如果校友不慎就会造成DrawCall飞涨的情况。  
   同样创建500个物体，每个物体大小都不相同，也就是transform中的scale属性不通，代码如下：  
   ```for(int i = 0; i< 500; i++)
    {
      GameObject cube;
      cube = GameObject.Instantiate(prefab) as GameObject;
      if(i/100 == 0){
          cube.transform.localScale = new Vector3(2+i,2+i,2+i);
      }
    }
    //DrawCall 101```

可以看到DrawCall的数量上升到了101次，Batching的数量也下降到了399.仅仅是一个简单的cude的创建，如果transform的属性不通，Unity3D竟然也不会去做批处理优化。这仅仅是动态批处理机制的一种约束。总结一下动态批处理的约束，也许能从中找到为什么动态批处理在自己项目中不起作用的原因。  
(1)批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。  
(2)如果着色器使用顶点位置，法线和UV值3种属性，那么只能批处理300顶点一下的物体；如果着色器需要使用顶点位置，法线，UV0,UV1和切向量，那么只能批处理180顶点一下的物体。  
(3)不要使用缩放。分别拥有缩放大小（1,1,1）和(2,2,2)的两个物体将不会进行批处理。  
(4)统一缩放的物体不会与非统一缩放的物体进行批处理。  
(5)使用缩放尺度(1,1,1)和(1,2,1)的两个物体将不会进行批处理，但是使用缩放尺度(1,2,1)和(1,3,1)的两个物体将可以进行批处理。    
(6)使用不同材质的实例化物体，将会导致批处理失败。  
(7)拥有lightmap的物体含有额外的（隐藏的）材质属性，例如lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非它们指向lightmap的同意部分）。  
(8)多通道的shader会妨碍批处理操作。比如几乎Unity3D中所有的着色器在前项渲染中都支持多个光源，并为他们有效的开辟多个通道。  
(9)预设体的实例会自动地使用相同的网格模型和材质。
  
* 所以这里建议开发者尽量使用静态的批处理



    
